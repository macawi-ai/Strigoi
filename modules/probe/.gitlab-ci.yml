# Strigoi Security Pipeline - GitLab CI
stages:
  - build
  - test
  - security
  - performance
  - deploy

variables:
  GO_VERSION: "1.20"
  GOLANGCI_LINT_VERSION: "v1.54.2"
  DOCKER_DRIVER: overlay2
  # Disable TLS for docker-in-docker
  DOCKER_TLS_CERTDIR: ""

# Build stage
build:go:
  stage: build
  image: golang:${GO_VERSION}-alpine
  before_script:
    - apk add --no-cache git make
  script:
    - go mod download
    - go build -v ./...
    - go build -race -v ./...
  artifacts:
    paths:
      - vendor/
    expire_in: 1 hour
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .go/pkg/mod/

# Test stage
test:unit:
  stage: test
  image: golang:${GO_VERSION}-alpine
  needs: ["build:go"]
  before_script:
    - apk add --no-cache git gcc musl-dev
  script:
    - go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...
    - go tool cover -func=coverage.txt
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.txt
    expire_in: 1 week

test:integration:
  stage: test
  image: golang:${GO_VERSION}
  needs: ["build:go"]
  services:
    - name: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
      alias: elasticsearch
      variables:
        discovery.type: single-node
        xpack.security.enabled: "false"
        ES_JAVA_OPTS: "-Xms512m -Xmx512m"
  variables:
    ELASTICSEARCH_URL: "http://elasticsearch:9200"
  script:
    - |
      # Wait for Elasticsearch
      for i in {1..30}; do
        curl -s http://elasticsearch:9200/_cluster/health && break
        echo "Waiting for Elasticsearch..."
        sleep 2
      done
    - go test -tags=integration -v ./...

# Security stage
security:static-analysis:
  stage: security
  image: golangci/golangci-lint:${GOLANGCI_LINT_VERSION}
  needs: []
  script:
    - golangci-lint run --timeout=5m ./...
  allow_failure: true

security:gosec:
  stage: security
  image: securego/gosec:latest
  needs: []
  script:
    - gosec -fmt json -out gosec-report.json ./...
  artifacts:
    reports:
      sast: gosec-report.json
    paths:
      - gosec-report.json
    expire_in: 1 week
  allow_failure: true

security:dependency-check:
  stage: security
  image: golang:${GO_VERSION}-alpine
  needs: []
  before_script:
    - apk add --no-cache git
    - go install golang.org/x/vuln/cmd/govulncheck@latest
  script:
    - govulncheck ./...
    - go mod verify
    - go list -json -deps ./... > deps.json
  artifacts:
    paths:
      - deps.json
    expire_in: 1 week

security:trivy:
  stage: security
  image: aquasec/trivy:latest
  needs: []
  script:
    - trivy fs --severity HIGH,CRITICAL --format json -o trivy-report.json .
  artifacts:
    reports:
      container_scanning: trivy-report.json
    paths:
      - trivy-report.json
    expire_in: 1 week

security:strigoi-audit:
  stage: security
  image: golang:${GO_VERSION}
  needs: ["build:go"]
  script:
    - go install ./security_audit/cmd/audit
    - audit -all -max-critical 0 -max-high 5 -format json -output audit-report.json
  artifacts:
    paths:
      - audit-report.json
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

# Performance stage
performance:benchmark:
  stage: performance
  image: golang:${GO_VERSION}
  needs: ["test:unit"]
  script:
    - go test -bench=. -benchmem -count=10 ./... | tee benchmark.txt
    - |
      # Compare with base branch if MR
      if [ -n "$CI_MERGE_REQUEST_ID" ]; then
        git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
        git checkout $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
        go test -bench=. -benchmem -count=10 ./... > base-bench.txt
        git checkout -
        go install golang.org/x/perf/cmd/benchstat@latest
        benchstat base-bench.txt benchmark.txt > bench-comparison.txt
        cat bench-comparison.txt
      fi
  artifacts:
    paths:
      - benchmark.txt
      - bench-comparison.txt
    expire_in: 1 week
  only:
    - merge_requests
    - main

performance:load-test:
  stage: performance
  image: golang:${GO_VERSION}
  needs: ["build:go"]
  script:
    - go build -o loadtest ./cmd/loadtest
    - ./loadtest -scenario all -duration 5m -output load-test-results.json
    - |
      # Extract key metrics
      jq '.summary' load-test-results.json
  artifacts:
    paths:
      - load-test-results.json
    expire_in: 1 week
  only:
    - schedules
    - main

# Deploy stage
deploy:docker:
  stage: deploy
  image: docker:latest
  services:
    - docker:dind
  needs: ["test:unit", "security:static-analysis"]
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - |
      if [ "$CI_COMMIT_BRANCH" == "main" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
        docker push $CI_REGISTRY_IMAGE:latest
      fi
  only:
    - main
    - develop
    - tags

deploy:release:
  stage: deploy
  image: golang:${GO_VERSION}
  needs: ["test:unit", "security:static-analysis"]
  before_script:
    - apt-get update && apt-get install -y git
    - go install github.com/goreleaser/goreleaser@latest
  script:
    - goreleaser release --clean
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  only:
    - tags

# Scheduled jobs
nightly:full-security-scan:
  extends: security:strigoi-audit
  only:
    - schedules
  variables:
    AUDIT_FLAGS: "-all -runtime -network -compliance OWASP,PCI-DSS"
  script:
    - go install ./security_audit/cmd/audit
    - audit $AUDIT_FLAGS -format html -output nightly-security-report.html

# Code quality job
code_quality:
  stage: test
  image: docker:stable
  services:
    - docker:stable-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    CODE_QUALITY_IMAGE: "registry.gitlab.com/gitlab-org/ci-cd/codequality:latest"
  script:
    - |
      docker run --rm \
        --env SOURCE_CODE="$PWD" \
        --volume "$PWD":/code \
        --volume /var/run/docker.sock:/var/run/docker.sock \
        "$CODE_QUALITY_IMAGE" /code
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    expire_in: 1 week
  allow_failure: true

# Pages job for documentation
pages:
  stage: deploy
  image: golang:${GO_VERSION}-alpine
  needs: ["security:strigoi-audit"]
  before_script:
    - apk add --no-cache git hugo
  script:
    - mkdir -p public
    - cp audit-report.json public/
    - |
      # Generate documentation site if hugo config exists
      if [ -f hugo.toml ]; then
        hugo --minify --destination public
      fi
  artifacts:
    paths:
      - public
  only:
    - main