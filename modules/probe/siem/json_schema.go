package siem

import (
	"fmt"
	"strings"
)

// StrigoiEventSchema defines the JSON schema for Strigoi security events
// This schema is compatible with Elastic Common Schema (ECS) v1.12
var StrigoiEventSchema = `{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://strigoi.security/schemas/security-event/v1.0.0",
  "title": "Strigoi Security Event",
  "description": "Schema for security events generated by Strigoi platform",
  "type": "object",
  "required": ["@timestamp", "event", "strigoi"],
  "properties": {
    "@timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Event timestamp in ISO8601 format"
    },
    "message": {
      "type": "string",
      "description": "Human-readable event message"
    },
    "event": {
      "type": "object",
      "required": ["type", "category"],
      "properties": {
        "type": {
          "type": "string",
          "description": "Event type",
          "enum": [
            "vulnerability_detected",
            "protocol_observation",
            "session_anomaly",
            "injection_attempt",
            "authentication_failure",
            "data_exposure"
          ]
        },
        "category": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "network",
              "intrusion_detection",
              "vulnerability",
              "authentication",
              "session",
              "configuration"
            ]
          },
          "description": "Event categories"
        },
        "severity": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100,
          "description": "Event severity (0=info, 21=low, 47=medium, 73=high, 100=critical)"
        },
        "risk_score_norm": {
          "type": "string",
          "pattern": "^[0-9]+$",
          "description": "Normalized risk score"
        }
      }
    },
    "strigoi": {
      "type": "object",
      "required": ["version", "session_id", "protocol"],
      "properties": {
        "version": {
          "type": "string",
          "description": "Strigoi version"
        },
        "session_id": {
          "type": "string",
          "description": "Session identifier"
        },
        "protocol": {
          "type": "string",
          "description": "Detected protocol",
          "enum": [
            "HTTP",
            "HTTPS",
            "WebSocket",
            "gRPC",
            "DNS",
            "TLS",
            "SQL",
            "Redis",
            "MongoDB",
            "MQTT",
            "AMQP",
            "Custom"
          ]
        },
        "dissector": {
          "type": "string",
          "description": "Dissector that processed the frame"
        },
        "evidence": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Evidence supporting the detection"
        },
        "remediation": {
          "type": "string",
          "description": "Recommended remediation steps"
        },
        "frame": {
          "type": "object",
          "additionalProperties": true,
          "description": "Protocol frame data"
        },
        "masked_fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Fields that were masked for privacy"
        }
      }
    },
    "source": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string",
          "format": "ipv4",
          "description": "Source IP address"
        },
        "port": {
          "type": "integer",
          "minimum": 0,
          "maximum": 65535,
          "description": "Source port"
        },
        "geo": {
          "type": "object",
          "properties": {
            "country_iso_code": {
              "type": "string",
              "pattern": "^[A-Z]{2}$"
            },
            "city_name": {
              "type": "string"
            },
            "location": {
              "type": "object",
              "properties": {
                "lat": {"type": "number"},
                "lon": {"type": "number"}
              }
            }
          }
        }
      }
    },
    "destination": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string",
          "format": "ipv4",
          "description": "Destination IP address"
        },
        "port": {
          "type": "integer",
          "minimum": 0,
          "maximum": 65535,
          "description": "Destination port"
        }
      }
    },
    "network": {
      "type": "object",
      "properties": {
        "protocol": {
          "type": "string",
          "description": "Network protocol"
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "Total bytes transferred"
        }
      }
    },
    "vulnerability": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Vulnerability type"
        },
        "name": {
          "type": "string",
          "description": "Vulnerability name/description"
        },
        "id": {
          "type": "string",
          "pattern": "^CVE-[0-9]{4}-[0-9]+$",
          "description": "CVE identifier"
        },
        "category": {
          "type": "string",
          "description": "OWASP category"
        },
        "score": {
          "type": "number",
          "minimum": 0,
          "maximum": 10,
          "description": "CVSS score"
        }
      }
    },
    "http": {
      "type": "object",
      "properties": {
        "request": {
          "type": "object",
          "properties": {
            "method": {
              "type": "string",
              "enum": ["GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "PATCH", "TRACE", "CONNECT"]
            }
          }
        },
        "response": {
          "type": "object",
          "properties": {
            "status_code": {
              "type": "integer",
              "minimum": 100,
              "maximum": 599
            }
          }
        }
      }
    },
    "url": {
      "type": "object",
      "properties": {
        "full": {
          "type": "string",
          "format": "uri",
          "description": "Full URL"
        }
      }
    },
    "user_agent": {
      "type": "object",
      "properties": {
        "original": {
          "type": "string",
          "description": "Original user agent string"
        }
      }
    },
    "dns": {
      "type": "object",
      "properties": {
        "question": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "DNS query name"
            },
            "type": {
              "type": "string",
              "description": "DNS query type"
            }
          }
        },
        "answers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "tls": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "pattern": "^[0-9]+\\.[0-9]+$"
        },
        "cipher": {
          "type": "string"
        },
        "server": {
          "type": "object",
          "properties": {
            "subject": {
              "type": "string"
            }
          }
        }
      }
    },
    "user": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "id": {
          "type": "string"
        }
      }
    },
    "process": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "pid": {
          "type": "integer"
        }
      }
    },
    "file": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "hash": {
          "type": "object",
          "properties": {
            "sha256": {
              "type": "string",
              "pattern": "^[a-f0-9]{64}$"
            }
          }
        }
      }
    },
    "tags": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "Event tags"
    },
    "labels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      },
      "description": "Custom labels"
    }
  }
}`

// SplunkCIMMapping provides Common Information Model field mappings for Splunk
var SplunkCIMMapping = map[string]string{
	"@timestamp":                "time",
	"source.ip":                 "src",
	"source.port":               "src_port",
	"destination.ip":            "dest",
	"destination.port":          "dest_port",
	"network.protocol":          "transport",
	"network.bytes":             "bytes",
	"http.request.method":       "http_method",
	"url.full":                  "url",
	"http.response.status_code": "status",
	"user_agent.original":       "http_user_agent",
	"vulnerability.type":        "signature",
	"vulnerability.id":          "cve",
	"event.severity":            "severity_id",
	"message":                   "signature",
}

// QRadarLEEFFormat generates LEEF format for IBM QRadar
func QRadarLEEFFormat(event *SecurityEvent) string {
	// LEEF:Version|Vendor|Product|Version|EventID|
	header := "LEEF:2.0|Strigoi|SecurityMonitor|1.0|%s|"

	// Build attributes
	attrs := []string{
		fmt.Sprintf("devTime=%d", event.Timestamp.Unix()*1000),
		fmt.Sprintf("severity=%d", event.EventSeverity/10), // LEEF uses 0-10 scale
		fmt.Sprintf("cat=%s", strings.Join(event.EventCategory, ",")),
		fmt.Sprintf("src=%s", event.SourceIP),
		fmt.Sprintf("dst=%s", event.DestinationIP),
		fmt.Sprintf("srcPort=%d", event.SourcePort),
		fmt.Sprintf("dstPort=%d", event.DestinationPort),
		fmt.Sprintf("proto=%s", event.NetworkProtocol),
		fmt.Sprintf("msg=%s", escapeLeef(event.Message)),
	}

	if event.VulnerabilityType != "" {
		attrs = append(attrs, fmt.Sprintf("vulnType=%s", event.VulnerabilityType))
	}
	if event.VulnerabilityCVE != "" {
		attrs = append(attrs, fmt.Sprintf("cve=%s", event.VulnerabilityCVE))
	}

	return fmt.Sprintf(header, event.EventType) + strings.Join(attrs, "\t")
}

// escapeLeef escapes special characters for LEEF format
func escapeLeef(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\t", "\\t")
	s = strings.ReplaceAll(s, "|", "\\|")
	s = strings.ReplaceAll(s, "=", "\\=")
	return s
}

// ArcSightCEFFormat generates CEF format for ArcSight
func ArcSightCEFFormat(event *SecurityEvent) string {
	// CEF:Version|Device Vendor|Device Product|Device Version|Device Event Class ID|Name|Severity|[Extension]
	header := "CEF:0|Strigoi|SecurityMonitor|1.0|%s|%s|%d|"

	// Map severity to CEF scale (0-10)
	cefSeverity := event.EventSeverity / 10
	if cefSeverity > 10 {
		cefSeverity = 10
	}

	// Build extensions
	exts := []string{
		fmt.Sprintf("rt=%d", event.Timestamp.Unix()*1000),
		fmt.Sprintf("src=%s", event.SourceIP),
		fmt.Sprintf("spt=%d", event.SourcePort),
		fmt.Sprintf("dst=%s", event.DestinationIP),
		fmt.Sprintf("dpt=%d", event.DestinationPort),
		fmt.Sprintf("proto=%s", event.NetworkProtocol),
		fmt.Sprintf("msg=%s", escapeCef(event.Message)),
		fmt.Sprintf("cat=%s", strings.Join(event.EventCategory, ",")),
	}

	if event.VulnerabilityType != "" {
		exts = append(exts, fmt.Sprintf("cs1=%s", event.VulnerabilityType))
		exts = append(exts, "cs1Label=VulnerabilityType")
	}
	if event.VulnerabilityCVE != "" {
		exts = append(exts, fmt.Sprintf("cs2=%s", event.VulnerabilityCVE))
		exts = append(exts, "cs2Label=CVE")
	}
	if event.VulnerabilityScore > 0 {
		exts = append(exts, fmt.Sprintf("cfp1=%.1f", event.VulnerabilityScore))
		exts = append(exts, "cfp1Label=CVSSScore")
	}

	return fmt.Sprintf(header, event.EventType, escapeCef(event.Message), cefSeverity) +
		strings.Join(exts, " ")
}

// escapeCef escapes special characters for CEF format
func escapeCef(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "=", "\\=")
	s = strings.ReplaceAll(s, "|", "\\|")
	return s
}

// GenerateFieldMappingDoc generates documentation for SIEM field mappings
func GenerateFieldMappingDoc() string {
	return `# Strigoi SIEM Field Mapping Guide

## Overview
This document describes how Strigoi security events map to various SIEM platforms.

## Elastic/ELK Stack
Strigoi events follow the Elastic Common Schema (ECS) v1.12 format natively.

### Key Field Mappings
| Strigoi Field | ECS Field | Type | Description |
|---------------|-----------|------|-------------|
| timestamp | @timestamp | date | Event timestamp |
| source_ip | source.ip | ip | Source IP address |
| dest_ip | destination.ip | ip | Destination IP address |
| protocol | network.protocol | keyword | Network protocol |
| vuln_type | vulnerability.type | keyword | Vulnerability type |
| severity | event.severity | long | Severity (0-100) |

## Splunk
Strigoi events can be ingested via HTTP Event Collector (HEC).

### CIM Field Mappings
| Strigoi Field | CIM Field | Description |
|---------------|-----------|-------------|
| source_ip | src | Source address |
| dest_ip | dest | Destination address |
| protocol | app | Application protocol |
| vuln_type | signature | Attack signature |
| severity | severity_id | Numeric severity |

### Recommended Sourcetype
` + "`" + `sourcetype=strigoi:security` + "`" + `

## IBM QRadar
Strigoi supports LEEF 2.0 format for QRadar integration.

### DSM Mapping
- Log Source Type: Strigoi Security Monitor
- Protocol: Syslog LEEF
- Event Categories mapped to QRadar categories

## ArcSight
Strigoi supports CEF format for ArcSight integration.

### CEF Field Usage
- Device Vendor: Strigoi
- Device Product: SecurityMonitor
- Severity: Mapped to 0-10 scale
- Custom fields for vulnerability details

## Data Privacy
All SIEM integrations support data masking for:
- Credit card numbers
- Social Security numbers
- API keys and tokens
- Email addresses (optional)
- IP addresses (optional)

## Best Practices
1. Enable TLS for all SIEM connections
2. Use dedicated service accounts with minimal permissions
3. Configure appropriate retention policies
4. Set up alerts for high-severity events
5. Regularly review masked field configurations
`
}
