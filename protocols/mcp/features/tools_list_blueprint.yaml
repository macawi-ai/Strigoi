# Feature Blueprint: tools/list
# Extracted from MCP Contract v2025-03-26
# Purpose: White-hat enumeration of available tools

feature:
  id: mcp_tools_list
  contract_ref: "MCP-2025-03-26#definitions.ListToolsRequest"
  risk_level: LOW
  white_hat_permitted: YES
  
specification:
  method: "tools/list"
  transport: "HTTP POST"
  content_type: "application/json"
  
  request:
    structure:
      jsonrpc: 
        type: string
        value: "2.0"
        required: true
        
      method:
        type: string
        value: "tools/list"
        required: true
        
      params:
        type: object
        fields:
          cursor:
            type: string
            required: false
            description: "Pagination token from previous response"
            
      id:
        type: integer
        required: true
        description: "Request identifier"
        
  response:
    success:
      structure:
        jsonrpc:
          type: string
          value: "2.0"
          
        result:
          type: object
          fields:
            tools:
              type: array
              items:
                type: object
                fields:
                  name:
                    type: string
                    required: true
                    
                  description:
                    type: string
                    required: false
                    
                  inputSchema:
                    type: object
                    required: true
                    
            nextCursor:
              type: string
              required: false
              description: "Token for next page"
              
        id:
          type: integer
          matches: request.id
          
    error:
      structure:
        jsonrpc: "2.0"
        error:
          code: integer
          message: string
        id: integer

test_requirements:
  assertions:
    - id: "valid_jsonrpc"
      description: "Response must be valid JSON-RPC 2.0"
      
    - id: "tools_array"
      description: "Result must contain tools array"
      
    - id: "tool_structure"
      description: "Each tool must have name and inputSchema"
      
    - id: "no_internal_exposure"
      description: "Should not expose internal/admin tools"
      validator: "regex_blacklist"
      patterns:
        - "admin.*"
        - "internal.*"
        - "debug.*"
        
    - id: "pagination_consistency"
      description: "Cursor behavior must be consistent"
      
implementation_constraints:
  rate_limit: "10 requests per minute"
  timeout: "5 seconds"
  retries: 0  # No retries to avoid amplification
  
  security_controls:
    - "Must not attempt to call discovered tools"
    - "Must not probe for hidden tools via parameter fuzzing"
    - "Must respect rate limits strictly"
    - "All requests must be logged with timestamp"
    
execution_template:
  go_struct: |
    type ToolsListRequest struct {
      JSONRPC string            `json:"jsonrpc"`
      Method  string            `json:"method"`
      Params  map[string]string `json:"params,omitempty"`
      ID      int               `json:"id"`
    }
    
    type Tool struct {
      Name        string          `json:"name"`
      Description string          `json:"description,omitempty"`
      InputSchema json.RawMessage `json:"inputSchema"`
    }
    
    type ToolsListResponse struct {
      JSONRPC string `json:"jsonrpc"`
      Result  struct {
        Tools      []Tool `json:"tools"`
        NextCursor string `json:"nextCursor,omitempty"`
      } `json:"result"`
      Error *RPCError `json:"error,omitempty"`
      ID    int       `json:"id"`
    }
    
  test_execution: |
    func TestToolsList(target string, manifest FeatureManifest) TestResult {
      // 1. Build request per blueprint
      req := ToolsListRequest{
        JSONRPC: "2.0",
        Method:  "tools/list",
        ID:      generateRequestID(),
      }
      
      // 2. Apply rate limiting
      rateLimiter.Wait()
      
      // 3. Execute with timeout
      ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
      defer cancel()
      
      resp, err := executeJSONRPC(ctx, target, req)
      
      // 4. Validate response against blueprint
      result := TestResult{
        Feature: "tools/list",
        Target:  target,
      }
      
      // Check all assertions
      if err != nil {
        result.Error = err
        return result
      }
      
      var toolsResp ToolsListResponse
      if err := json.Unmarshal(resp, &toolsResp); err != nil {
        result.Failed("invalid_json", err)
        return result
      }
      
      // Validate structure
      if toolsResp.JSONRPC != "2.0" {
        result.Failed("invalid_jsonrpc", "not 2.0")
      }
      
      // Check for internal tool exposure
      for _, tool := range toolsResp.Result.Tools {
        if matchesBlacklist(tool.Name) {
          result.SecurityFinding(
            "internal_tool_exposed",
            fmt.Sprintf("Tool '%s' should not be exposed", tool.Name),
          )
        }
      }
      
      result.Passed()
      return result
    }