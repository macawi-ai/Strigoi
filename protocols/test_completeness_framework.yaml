# Test Completeness Framework
# Totality Pattern: What was tested, what wasn't, and why

framework:
  version: "1.0.0"
  principle: "Complete transparency about test coverage"
  
completeness_model:
  
  # Every protocol has a universe of testable features
  test_universe:
    discovered_features:
      - source: "contract_analysis"
        items: ["methods", "parameters", "data_types"]
      - source: "enumeration"
        items: ["tools", "prompts", "resources", "capabilities"]
      - source: "schema_inspection"
        items: ["input_schemas", "output_formats", "error_codes"]
    
    theoretical_features:
      - source: "specification_gaps"
        items: ["undocumented_methods", "hidden_parameters"]
      - source: "version_differences"
        items: ["deprecated_features", "beta_endpoints"]
      - source: "implementation_specific"
        items: ["vendor_extensions", "custom_headers"]
  
  # Test execution produces a coverage map
  coverage_map:
    tested:
      feature_id: STRING
      test_class: ENUM[ENUMERATION, DATA_ACCESS, EXECUTION, STATE_MODIFICATION, CONFIGURATION]
      tests_performed: ARRAY[test_id]
      test_results: ARRAY[PASS, FAIL, BLOCKED, SKIPPED]
      evidence: HASH
      timestamp: ISO8601
      
    not_tested:
      feature_id: STRING
      reason: ENUM[
        WHITE_HAT_RESTRICTED,    # Would violate ethical constraints
        AUTHENTICATION_REQUIRED,  # Couldn't obtain valid auth
        DEPENDENCY_MISSING,      # Requires another feature first
        RISK_TOO_HIGH,          # Would damage system
        TIME_CONSTRAINED,       # Ran out of test window
        RATE_LIMITED,           # Hit API limits
        NOT_DISCOVERED          # Feature hidden/undocumented
      ]
      recommended_action: STRING
      risk_assessment: ENUM[LOW, MEDIUM, HIGH, CRITICAL, UNKNOWN]
      
    partially_tested:
      feature_id: STRING
      coverage_percentage: FLOAT
      tested_aspects: ARRAY[STRING]
      untested_aspects: ARRAY[STRING]
      limitations: ARRAY[STRING]

# Signed manifest ensures test authenticity
agent_manifold:
  structure:
    identity:
      name: "Strigoi"
      version: STRING  # e.g., "1.0.0-beta.2"
      build: STRING    # git commit hash
      
    test_capabilities:
      supported_protocols: ARRAY[STRING]
      test_classes: ARRAY[STRING]
      white_hat_constraints: ARRAY[STRING]
      
    certification:
      signed_by: STRING     # GPG key ID
      signature: STRING     # Detached signature
      timestamp: ISO8601
      cert_chain: ARRAY[STRING]
      
    execution_environment:
      platform: STRING
      runtime: STRING
      dependencies: MAP[STRING, VERSION]
      
  validation:
    - "Signature must be valid"
    - "Timestamp within 24 hours"
    - "Version matches binary"
    - "Dependencies satisfied"

# Reporting includes both tested and untested
report_structure:
  
  executive_summary:
    total_features_discovered: INTEGER
    features_tested: INTEGER
    features_not_tested: INTEGER
    features_partially_tested: INTEGER
    coverage_percentage: FLOAT
    critical_gaps: ARRAY[STRING]
    
  tested_features:
    - feature: STRING
      risk_score: INTEGER
      findings: ARRAY[finding]
      evidence: ARRAY[evidence_hash]
      
  untested_features:
    - feature: STRING
      reason: STRING
      estimated_risk: STRING
      recommendation: STRING
      
  partially_tested:
    - feature: STRING
      coverage: PERCENTAGE
      tested: ARRAY[STRING]
      gaps: ARRAY[STRING]
      
  test_metadata:
    manifold: agent_manifold
    duration: DURATION
    timestamp: ISO8601
    parameters_used: MAP
    
# Parameters for output control
output_parameters:
  
  completeness_mode:
    FULL:          # Everything: tested + untested + partial
    TESTED_ONLY:   # Just what we tested
    GAPS_ONLY:     # Just what we couldn't test
    SUMMARY:       # High-level coverage stats
    
  risk_filtering:
    SHOW_ALL:           # All findings regardless of risk
    CRITICAL_ONLY:      # Critical findings only
    ABOVE_THRESHOLD:    # User-defined risk threshold
    
  evidence_level:
    FULL:          # Complete request/response pairs
    SANITIZED:     # Sensitive data removed
    SUMMARY:       # Just verdicts, no raw data
    HASHES:        # Evidence hashes for verification

# Example usage in metacode
example_metacode:
  test_completion:
    on_feature_discovered:
      - ADD_TO_TEST_UNIVERSE
      - EVALUATE_WHITE_HAT_PERMISSION
      - ASSIGN_TO_COVERAGE_MAP
      
    on_test_blocked:
      - RECORD_REASON
      - ASSESS_RISK_OF_UNTESTED
      - ADD_TO_NOT_TESTED
      
    on_test_complete:
      - RECORD_RESULTS
      - GENERATE_EVIDENCE_HASH
      - UPDATE_COVERAGE_MAP
      
    on_report_generation:
      - CALCULATE_TOTALITY
      - APPLY_OUTPUT_PARAMETERS
      - SIGN_WITH_MANIFOLD

# Untested feature risk assessment
risk_of_untested:
  calculation: |
    # Base risk from feature classification
    base_risk = ontology.function_class.risk_base
    
    # Adjust for why we couldn't test
    if reason == WHITE_HAT_RESTRICTED:
      # We couldn't test because it's destructive
      implied_risk = HIGH
    elif reason == AUTHENTICATION_REQUIRED:
      # May hide vulnerable features
      implied_risk = MEDIUM
    elif reason == NOT_DISCOVERED:
      # Hidden features often security-relevant
      implied_risk = HIGH
    
    # Factor in context
    if similar_features_vulnerable:
      risk *= 2.0
    if protocol_has_known_issues:
      risk *= 1.5
      
    return min(risk, CRITICAL)